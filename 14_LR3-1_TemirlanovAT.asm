use16
org 100h

;di - номер строки (номер по списку + 3) 
mov di, 17
;si - номер столбца (сдвиг вправо от крайней левой точки)
mov si, 40
;см 2 вопрос в туториале
mov dh, 0xCE
mov dl, 0x41

call print

mov ax,0
int 16h
int 20h

print:
    ;Принято, что в начале процедуры все регистры помещаются в стек, чтобы можно было с ними безопасно работать
    pusha
    ;Отдельно кладём dx в вершину стека, чтобы его можно было его обратно вывести без повреждения регистра dx
    push dx

    ; В es кладём адрес видеобуфера через ax, потому что Ассемблер так сказал, чтобы выводить данные на экран
    mov ax, 0xb800
    mov es, ax

    ;Зная, что в одной строке 80 символов, каждый символ по 2 байта, то одна строка = 160 байт
    ;Умножая номер строки на 160, получим смещение на n количество строк
    mov ax, 0xa0 ;0xa0 = 160
    dec di  ; Уменьшаем di на 1, потому что он выводит на 1 строку больше
    mul di  ; mul умножает регистр на ax и ЗАПИСЫВАЕТ результат в AX!!!!!!
    mov di, ax ; Помещаем значение из AX в dx из-за особенности операции mul
    
    ;Так же уменьшаем si на 1, потому что выводит на 1 столбец больше
    dec si
    ;Сдвигаем значение регистра si влево на 1, что эквивалентно умножению на 2, но быстрее
    ;Умножаем на 2, т.к. в каждом символе 2 байта
    shl si, 1

    ;Складываем si и di и записываем это в si (можно было и в di, разницы особой нет, как я знаю)
    add si, di

    ;Выводим dx, в котором хранится инфа о символе
    pop dx
    ;Помещаем значение dx в слово в видеобуфере со смещением si
    mov word[es:si], dx
    ;В конце возвращаем обратно все значения из стека в регистры
    popa
    ; Возврат в последнее call
    ret