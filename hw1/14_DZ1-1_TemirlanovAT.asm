use16
org 100h

call main

xor ax, ax
int 16h
int 20h



main:
	;Назначение видеобуфера
	mov ax, 0xb800
	mov es, ax
	;обнуляем смещение от адреса видеобуфера
	xor di, di
	

	mov cx, 100 		;Количество проходов выводимого слова
	lp3:
		mov dx, 5	;Длина выводимой строки
		mov ax, 25	;Сколько пройдёт слово за один цикл
		call print_loop	;Вывод целого прохождения слова сверху вниз
		loop lp3
	ret

print_loop:
	pusha
	cld		
	mov bx, dx			 ;Процедура drive принимает bx как количество символов слова msg, которое надо вывести
	mov cx, ax 			 ;Слово будет "бежать" до достижения этой строки
	lp1:	
		call drive 		 ;Вывод целого слова
	
		call Delay	

		
		mov word[es:di], 0x0000  ;Очищение первого символа слова
		add di, 160		 ;Смещение от начала вывода слова на 1 строку
		loop lp1
	
	popa
	ret

drive:	
	pusha		  ;Обеспечивает сохранение данных всех регистров, включая di, т.к. при выводе movsw меняет si и di
	mov si, msg	  ;Запись в сегмент данных слово msg

	mov cx, bx 	  
	lp:
		movsw	  ;Копирование символа из сегмента данных в видеобуфер
		call endl ;Смещение на следующую строку, либо на начало видеобуфера в зависимости от "координат" слова
		loop lp

	popa		  ;Возврат исходного значения di и остальных регистров
	ret

endl:
	add di, 158	  ;Т.к. movsw смещает di и si на 2, то для перевода на следующую строку прибавляем 158, а не 160

	mov bx, ax	  ;Ниже строки нужны, чтобы не изменяя ax проверить смещение di на достижение последней строки 

	push ax

	mov ax, 160
	mul bx
	mov bx, ax
	
	pop ax		  ;Возвращения значения ax
	
	cmp di, bx	  ;Проверка на то, что di сместилось до последней строки
	
	je to_top
	ret	

to_top:
	xor di, di	  ;Переход на начало видеобуфера для вывода символов, которые не "вместились" в количество строк, заданных в начале программы  
	ret


Delay:			;Реализация задержки
	pusha
	mov ah, 0x0
	int 1ah
.Wait:
	push dx
	mov ah,0x0
	int 1ah
	pop bx
	cmp bx, dx
	je .Wait
	popa
	ret


msg dw 0xCE48, 0xCE65, 0xCE6C, 0xCE6C, 0xCE6F  ;Слово "Hello" с жёлтым текстом и красным фоном
